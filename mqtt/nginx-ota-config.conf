# Configuração nginx para Servidor OTA - Sistema MQTT IoT
# Arquivo: /etc/nginx/sites-available/ota-firmware

server {
    listen 80;
    server_name firmware.iot.local 10.102.0.101;
    
    # Diretório raiz dos firmwares
    root /var/www/firmware;
    
    # Logs específicos para OTA
    access_log /var/log/nginx/ota-access.log;
    error_log /var/log/nginx/ota-error.log;
    
    # Headers de segurança e CORS para ESP32
    add_header 'Access-Control-Allow-Origin' '*' always;
    add_header 'Access-Control-Allow-Methods' 'GET, HEAD, OPTIONS' always;
    add_header 'Access-Control-Allow-Headers' 'Range' always;
    add_header 'X-Content-Type-Options' 'nosniff' always;
    add_header 'X-Frame-Options' 'DENY' always;
    
    # Endpoint principal para firmwares
    location /firmware/ {
        alias /var/www/firmware/;
        autoindex on;
        autoindex_exact_size off;
        autoindex_localtime on;
        
        # Configurações específicas por tipo de arquivo
        
        # Arquivos .bin (firmwares) - cache por 1 hora
        location ~* \.bin$ {
            expires 1h;
            add_header Cache-Control "public, immutable";
            add_header Content-Type "application/octet-stream";
            
            # Suporte a Range requests para downloads grandes
            add_header Accept-Ranges bytes;
            
            # Log específico para downloads de firmware
            access_log /var/log/nginx/firmware-downloads.log;
        }
        
        # Arquivos .json (versões) - sem cache
        location ~* \.json$ {
            expires -1;
            add_header Cache-Control "no-cache, no-store, must-revalidate";
            add_header Content-Type "application/json; charset=utf-8";
        }
        
        # Arquivos .md5 (checksums) - sem cache
        location ~* \.(md5|sha256)$ {
            expires -1;
            add_header Cache-Control "no-cache, no-store, must-revalidate";
            add_header Content-Type "text/plain; charset=utf-8";
        }
        
        # Bloquear acesso a arquivos temporários
        location ~* \.(tmp|temp|bak|backup)$ {
            deny all;
        }
    }
    
    # API endpoint para verificação de versão
    location /api/version {
        default_type application/json;
        return 200 '{"status":"ok","server":"nginx-ota","timestamp":"$time_iso8601"}';
    }
    
    # Endpoint para listar tipos de dispositivos
    location /api/device-types {
        alias /var/www/firmware/;
        autoindex on;
        autoindex_format json;
        default_type application/json;
    }
    
    # Endpoint específico para verificar versão de um tipo
    location ~ ^/api/device-types/([^/]+)/version$ {
        alias /var/www/firmware/$1/latest/version.json;
        default_type application/json;
        
        # Se não existir, retornar 404 JSON
        try_files $uri @not_found_json;
    }
    
    # Endpoint para download direto da versão mais recente
    location ~ ^/api/device-types/([^/]+)/latest/firmware$ {
        alias /var/www/firmware/$1/latest/firmware.bin;
        add_header Content-Type "application/octet-stream";
        add_header Content-Disposition 'attachment; filename="$1-latest.bin"';
        
        try_files $uri @not_found_json;
    }
    
    # Handler para 404 em JSON
    location @not_found_json {
        default_type application/json;
        return 404 '{"error":"Not found","message":"Firmware or version not available"}';
    }
    
    # Status do servidor OTA
    location /status {
        default_type application/json;
        return 200 '{"server":"nginx-ota","status":"running","firmware_count":"$upstream_cache_status"}';
    }
    
    # Bloquear acesso a arquivos ocultos
    location ~ /\. {
        deny all;
    }
    
    # Configurações de performance
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    client_max_body_size 50M;
    
    # Compressão para arquivos JSON
    gzip on;
    gzip_types application/json text/plain;
    gzip_min_length 1000;
}

# Configuração adicional para HTTPS (recomendado para produção)
# server {
#     listen 443 ssl;
#     server_name firmware.iot.local;
#     
#     ssl_certificate /etc/ssl/certs/firmware.iot.local.crt;
#     ssl_certificate_key /etc/ssl/private/firmware.iot.local.key;
#     
#     # Redirecionar para configuração HTTP acima
#     # ... (mesmas configurações)
# } 